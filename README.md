[![Build status](https://ci.appveyor.com/api/projects/status/rsvlu24m8jdxdbql?svg=true)](https://ci.appveyor.com/project/refactorsaurusrex/whats-new)

# What's New?!

![whats-new](/whats-new.png) 

Powershell functions for versioning a git repo with tags and more!

## Background

This module is essentially my personal PowerShell toolbelt: a collection of functions that I myself use on a regular basis at work and on the side. It originally started with just the four commands to create semantically versioned tags in git repositories, but has expanded into the smorgasbord of semi-related functionality you see here today. 

# Features 
...at a glance. For more details, [check out the wiki](https://github.com/refactorsaurusrex/whats-new/wiki).

## Semantically versioned git tags

Easily add [semantically versioned](https://semver.org/) tags to your git commits with the following functions:

- `Add-MajorVersionTag`: Create a new tag with the *major* version incremented.
- `Add-MinorVersionTag`: Create a new tag with the *minor* version incremented.
- `Add-PatchVersionTag`: Create a new tag with the *patch* version incremented.
- `New-VersionTag`: Create a new tag with an *arbitrary* version number.

The *Major*, *Minor*, and *Patch* functions will find the most recent semantically versioned tag and use it as the basis for the incrementation operation, according to semantic versioning rules. 

## Delete old local git branches

Delete all local branches in a git repo except for master. Useful for those moments when you realize you have an enormous number of obsolete branches that are ready for the big `-D`.

`Remove-LocalBranches`

By default, this will only remove merged branches. Use `-Force` to delete both [merged and unmerged branches](https://git-scm.com/docs/git-branch#git-branch--d).

## Open Visual Studio solutions from the command line

Why fish around for Visual Studio solution files using Windows Explorer when you can find and launch them from your terminal window with just three little letters? Run `sln` (an alias for `Open-Solution`) to recursively search your current working directory for a solution file and launch it, if one is found.

## Remove autogenerated comments from PowerShell module manifests

When you use the `New-ModuleManifest` cmdlet to create a module manifest, it generates a _lot_ of comments that you may not want to keep. Run `Remove-ModuleManifestComments` to strip away that noise and make your manifest easy to read.

## Export names and aliases from cmdlets and functions

In order to create a well-formed PowerShell module manifest, it's "recommended" that you _explicitly_ list out all functions, cmdlets, variables, and aliases that should be exported. I say "recommended" with quotes because using wildcards for these lists - while technically allowable - will break module autoloading in PowerShell 6. (This doesn't appear to be an issue with PowerShell 5.) So if module autoloading is important to you and you want to target PowerShell 6, you're pretty much required to explicitly list these items out. Regardless of all that, the reason we're encouraged/required to list these out is for performance. Loading all cmdlets, functions, aliases, and variables from a large module can be a surprisingly slow process. 

Okay, I get it. Autoloading only essential functionality from a module makes things faster. The problem is that manually listing out all functions, cmdlets, variables, and aliases from an even moderately complex module is a _pain in the ass!_ What if a name changes? What if functionality is removed or added? Am I supposed to remember to *manually* update my manifest? Fat chance.

This called for some good, old fashioned automation and a few new cmdlets to export function, cmdlet, variable, and alias names from binary modules and scripts. That way I can reconstruct my module manifest dynamically at build time, [like this](https://github.com/refactorsaurusrex/whats-new/blob/master/build.ps1#L32-L70) (truncated below):

```powershell
$moduleInfo = Get-Module WhatsNew
$cmdletNames = Export-BinaryCmdletNames -ModuleInfo $moduleInfo
$cmdletAliases = Export-BinaryCmdletAliases -ModuleInfo $moduleInfo

$scriptFiles = Get-ChildItem -Path "$PSScriptRoot\src\script-modules" -File
$scriptAliases = $scriptFiles | 
  Select-Object -ExpandProperty FullName | 
  Export-PSScriptAliases
$scriptFunctions = $scriptFiles | 
  Select-Object -ExpandProperty FullName | 
  Export-PSScriptFunctionNames

$newManifestArgs = @{
  ModuleVersion = $Version
  AliasesToExport = $cmdletAliases + $scriptAliases
  NestedModules = $modules
  CmdletsToExport = $cmdletNames
  FunctionsToExport = $scriptFunctions
}

New-ModuleManifest @newManifestArgs
```

## Create a Table of Contents

...for your GitHub wiki home page, [just like this](https://github.com/refactorsaurusrex/whats-new/wiki#list-of-all-available-commands) with the [New-MarkdownTableOfContents](https://github.com/refactorsaurusrex/whats-new/wiki/New-MarkdownTableOfContents) cmdlet.

**Pro Tip:** Install [ClipboardText](https://www.powershellgallery.com/packages/ClipboardText) to pipe your ToC right to your clipboard. 

## Make Yaml Front Matter Pretty on GitHub

If you happen to use [platyPS](https://github.com/PowerShell/platyPS) to create markdown documentation for PowerShell modules (as I do), you may have noticed that the metadata platyPS emits as yaml front matter doesn't render all that nicely on GitHub. Use [Switch-YamlFrontMatterToCodeFence](https://github.com/refactorsaurusrex/whats-new/wiki/Switch-YamlFrontMatterToCodeFence) to make it pretty on GitHub and [Switch-CodeFenceToYamlFrontMatter](https://github.com/refactorsaurusrex/whats-new/wiki/Switch-CodeFenceToYamlFrontMatter) to switch it back as needed. 

# Installation

Get it from the [PowerShell Gallery](https://www.powershellgallery.com/packages/WhatsNew): 

`Install-Module -Name WhatsNew`

# Contributions & Bug Reports

[Read the guidelines here.](/CONTRIBUTING.MD) 
